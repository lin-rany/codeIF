{"canonical_solution": "\ntype LRUCache struct {\n\tsize       int\n\tcapacity   int\n\tcache      map[string]*DLinkedNode\n\thead, tail *DLinkedNode\n}\n\ntype DLinkedNode struct {\n\tkey        string\n\tvalue      int\n\tprev, next *DLinkedNode\n}\n\nfunc initDLinkedNode(key string, value int) *DLinkedNode {\n\treturn &DLinkedNode{\n\t\tkey:   key,\n\t\tvalue: value,\n\t}\n}\n\nfunc CreateLRUCache(capacity int) LRUCache {\n\tl := LRUCache{\n\t\tcache:    map[string]*DLinkedNode{},\n\t\thead:     initDLinkedNode(\"\", 0),\n\t\ttail:     initDLinkedNode(\"\", 0),\n\t\tcapacity: capacity,\n\t}\n\tl.head.next = l.tail\n\tl.tail.prev = l.head\n\treturn l\n}\n\nfunc (this *LRUCache) Get(key string) int {\n\tif _, ok := this.cache[key]; !ok {\n\t\treturn -1\n\t}\n\tnode := this.cache[key]\n\tthis.moveToHead(node)\n\treturn node.value\n}\n\nfunc (this *LRUCache) Put(key string, value int) {\n\tif _, ok := this.cache[key]; !ok {\n\t\tnode := initDLinkedNode(key, value)\n\t\tthis.cache[key] = node\n\t\tthis.addToHead(node)\n\t\tthis.size++\n\t\tif this.size > this.capacity {\n\t\t\tremoved := this.removeTail()\n\t\t\tdelete(this.cache, removed.key)\n\t\t\tthis.size--\n\t\t}\n\t} else {\n\t\tnode := this.cache[key]\n\t\tnode.value = value\n\t\tthis.moveToHead(node)\n\t}\n}\n\nfunc (this *LRUCache) addToHead(node *DLinkedNode) {\n\tnode.prev = this.head\n\tnode.next = this.head.next\n\tthis.head.next.prev = node\n\tthis.head.next = node\n}\n\nfunc (this *LRUCache) removeNode(node *DLinkedNode) {\n\tnode.prev.next = node.next\n\tnode.next.prev = node.prev\n}\n\nfunc (this *LRUCache) moveToHead(node *DLinkedNode) {\n\tthis.removeNode(node)\n\tthis.addToHead(node)\n}\n\nfunc (this *LRUCache) removeTail() *DLinkedNode {\n\tnode := this.tail.prev\n\tthis.removeNode(node)\n\treturn node\n}", "content": "请用 go 语言实现一个 LRU 缓存的工具，创建时设置容量参数 capacity。\n支持 get 方法，返回缓存的数据，不存在时返回 -1\n支持 put 方法，如果 key 已存在，覆盖当前的值，如果不存在，插入数据，如果插入后保存的数据量超过了 capacity ，则逐出最久未使用的数据\n需要实现以下函数完成上述任务：\n`func CreateLRUCache(capacity int) LRUCache`\n`func (this *LRUCache) Get(key string) int`\n`func (this *LRUCache) Put(key string, value int)`", "id": 1, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "easy", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n\n#<INSERT>\n\nfunc TestLRU(t *testing.T) {\n\tlru := CreateLRUCache(2)\n\n\tlru.Put(\"a\", 1)\n\tlru.Put(\"b\", 2)\n\tlru.Put(\"c\", 3)\n\tlru.Put(\"a\", 4)\n\n\tif lru.Get(\"a\") == 4 && lru.Get(\"b\") == -1 && lru.Get(\"c\") == 3 {\n\t\tt.Log(\"get expect\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected\")\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "import (\n\t\"container/heap\"\n)\n\ntype ArrayEntry struct {\n\tIndex  int\n\tValue  int\n\tCursor int\n}\ntype KMergeArray []ArrayEntry\n\nfunc (h KMergeArray) Len() int { return len(h) }\nfunc (h KMergeArray) Less(i, j int) bool {\n\treturn h[i].Value < h[j].Value || (h[i].Value == h[j].Value && h[i].Index < h[j].Index)\n}\nfunc (h KMergeArray) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\n\nfunc (h *KMergeArray) Push(x interface{}) {\n\t*h = append(*h, x.(ArrayEntry))\n}\n\nfunc (h *KMergeArray) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n\nfunc MergeKSortedArrays(arrays [][]int) []int {\n\tvar arrayEntry []ArrayEntry\n\tfor i, array := range arrays {\n\t\tif len(array) != 0 {\n\t\t\tarrayEntry = append(arrayEntry, ArrayEntry{\n\t\t\t\tIndex:  i,\n\t\t\t\tValue:  array[0],\n\t\t\t\tCursor: 0,\n\t\t\t})\n\t\t}\n\t}\n\th := KMergeArray(arrayEntry)\n\theap.Init(&h)\n\tsorted := []int{}\n\tfor len(h) > 0 {\n\t\ttop := heap.Pop(&h).(ArrayEntry)\n\t\tsorted = append(sorted, top.Value)\n\t\ttop.Cursor += 1\n\t\tif top.Cursor < len(arrays[top.Index]) {\n\t\t\ttop.Value = arrays[top.Index][top.Cursor]\n\t\t\theap.Push(&h, top)\n\t\t}\n\t}\n\treturn sorted\n}", "content": "请用 go 语言实现一个函数 `MergeKSortedArrays`，该函数接收一个二维整数数组作为输入参数，其中包含 k 个已排序的整数数组，要求将这 k 个数组合并成一个有序数组并返回。\n\n函数签名：\n```go\nfunc MergeKSortedArrays(arrays [][]int) []int\n```\n\n要求：\n1. 输入保证每个子数组都是按升序排列的\n2. 请使用最小堆来实现该算法\n3. 返回的数组应该是升序排列的", "id": 2, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport (\n\t\"testing\"\n)\n\n#<INSERT>\nfunc TestMergeKSortedArrays(t *testing.T) {\n\tarrays := [][]int{\n\t\t{1, 3, 5, 7, 9, 11},\n\t\t{2, 4, 6, 8, 10, 12},\n\t\t{1, 2, 3, 5, 9, 10, 18},\n\t}\n\tsorted := MergeKSortedArrays(arrays)\n\tactual := sorted[6]\n\texpected := 4\n\tif actual == expected {\n\t\tt.Log(\"get data succeed\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected expected %v actual %v\", expected, actual)\n\t\tt.FailNow()\n\t}\n\n}"}}
{"canonical_solution": "func EmployeeCountIf(list []Employee, fn func(e *Employee) bool) int {\n\tcount := 0\n\tfor i, _ := range list {\n\t\tif fn(&list[i]) {\n\t\t\tcount += 1\n\t\t}\n\t}\n\treturn count\n}\n\n\nfunc CountEmployeesAgeLtV2(age int) int {\n\told := EmployeeCountIf(list, func(e *Employee) bool {\n\t\treturn e.Age < age\n\t})\n\treturn old\n}", "content": "请用go语言回答, 为了灵活的支持查询各种员工统计信息，需要实现EmployeeCountIf(list []Employee, fn func(e *Employee) bool) int 函数，让调用者来决定查询条件。\n基于EmployeeCountIf函数，重写CountEmployeesAgeLtV1实现,并将函数CountEmployeesAgeLtV1更名为CountEmployeesAgeLtV2,最终计算小于40岁的员工数量。\n```go\ntype Employee struct {\n\tName     string\n\tAge      int\n\tVacation int\n\tSalary   int\n}\n\nvar list = []Employee{\n\t{\"Hao\", 44, 0, 8000},\n\t{\"Bob\", 34, 10, 5000},\n\t{\"Alice\", 23, 5, 9000},\n\t{\"Jack\", 26, 0, 4000},\n\t{\"Tom\", 48, 9, 7500},\n\t{\"Marry\", 29, 0, 6000},\n\t{\"Mike\", 32, 8, 4000},\n}\n\nfunc CountEmployeesAgeLtV1(age int) int {\n\tcount := 0\n\tfor _, employee := range list {\n\t\tif employee.Age > age {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n```\n注意回答的代码中不要重复定义以上结构与变量", "id": 3, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Data Analysis", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport \"testing\"\n\n#<INSERT>\n\ntype Employee struct {\n\tName     string\n\tAge      int\n\tVacation int\n\tSalary   int\n}\n\nvar list = []Employee{\n\t{\"Hao\", 44, 0, 8000},\n\t{\"Bob\", 34, 10, 5000},\n\t{\"Alice\", 23, 5, 9000},\n\t{\"Jack\", 26, 0, 4000},\n\t{\"Tom\", 48, 9, 7500},\n\t{\"Marry\", 29, 0, 6000},\n\t{\"Mike\", 32, 8, 4000},\n}\n\nfunc TestEmploee_CountV2(t *testing.T) {\n\tresult := CountEmployeesAgeLtV2(40)\n\texpected :=5 \n\tif result != expected {\n\t\tt.Errorf(\"The number of employees aged over 40 years old is %d; expected %d\", result, expected)\n\t\tt.FailNow()\n\t}\n\n}"}}
{"canonical_solution": "import (\n\t\"container/heap\"\n)\ntype ArrayEntry struct {\n\tIndex int\n\tValue int\n}\n\ntype MaxHeap []ArrayEntry\n\nfunc (h MaxHeap) Len() int { return len(h) }\nfunc (h MaxHeap) Less(i, j int) bool {\n\treturn h[i].Value > h[j].Value || (h[i].Value == h[j].Value && h[i].Index < h[j].Index)\n}                               // 大顶堆\nfunc (h MaxHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\n\nfunc (h *MaxHeap) Push(x interface{}) {\n\t*h = append(*h, x.(ArrayEntry))\n}\n\nfunc (h *MaxHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n\nfunc StructHeapSort(array []ArrayEntry) []ArrayEntry {\n\th := MaxHeap(array)\n\theap.Init(&h)\n\tsorted := []ArrayEntry{}\n\tfor len(h) > 0 {\n\t\tsorted = append(sorted, heap.Pop(&h).(ArrayEntry))\n\t}\n\treturn sorted\n}", "content": "需要对一个Struct结构进行堆排序算法，请写出相关的代码\n```go\ntype ArrayEntry struct {\n\tIndex int\n\tValue int\n}\n```\n排序的优先级是：Value降序，Index升序，优先按照Value排序，实现函数 func StructHeapSort(array []ArrayEntry) []ArrayEntry", "id": 4, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport (\n\t\"testing\"\n)\n\n#<INSERT>\nfunc TestStructHeapSort(t *testing.T) {\n\tarrayEntry := []ArrayEntry{\n\t\t{Index: 1, Value: 3},\n\t\t{Index: 2, Value: 1},\n\t\t{Index: 3, Value: 2},\n\t\t{Index: 4, Value: 5},\n\t\t{Index: 5, Value: 1},\n\t}\n\tsorted := StructHeapSort(arrayEntry)\n\tactual := sorted[4]\n\texpected := ArrayEntry{\n\t\t5, 1,\n\t}\n\tif actual == expected {\n\t\tt.Log(\"get data succeed\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected expected %v actual %v\", expected, actual)\n\t\tt.FailNow()\n\t}\n\tt.Log(sorted)\n}"}}
{"canonical_solution": "import \"fmt\"\ntype Task int\nfunc ProcessTask(task Task) {\n        fmt.Printf(\"Processing task %v\\n\", task)\n}\n\nfunc ProcessConcurrently(tasks []Task, maxConcurrent int, processFunc func(Task)) {\n        var wg sync.WaitGroup\n        semaphore := make(chan struct{}, maxConcurrent)\n        for _, task := range tasks {\n                wg.Add(1)\n                semaphore <- struct{}{} \n                go func(t Task) {\n                        defer wg.Done()\n                        processFunc(t)\n                        <-semaphore \n                }(task)\n        }\n        wg.Wait() \n}", "content": "使用go实现一个函数ProcessConcurrently(tasks []Task, maxConcurrent int，processFunc func(Task))，接受一个任务列表并发地执行任务ProcessTask(task Task)，需要限制同时最多有maxConcurrent个任务在执行。", "id": 5, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Desktop and Web Development", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport (\n        \"sync\"\n        \"sync/atomic\"\n        \"testing\"\n        \"time\"\n)\n\n#<INSERT>\n\n\nfunc TestProcessConcurrently(t *testing.T) {\n        maxConcurrent := 10\n        numTasks := 50\n        var concurrentCount int32 \n        var peakConcurrentCount int32 \n        mockProcessTask := func(task Task) {\n                atomic.AddInt32(&concurrentCount, 1) \n                for {\n                        current := atomic.LoadInt32(&concurrentCount)\n                        peak := atomic.LoadInt32(&peakConcurrentCount)\n                        if current > peak {\n                                if atomic.CompareAndSwapInt32(&peakConcurrentCount, peak, current) {\n                                        break\n                                }\n                        } else {\n                                break\n                        }\n                }\n                time.Sleep(10 * time.Millisecond) \n                atomic.AddInt32(&concurrentCount, -1) \n        }\n\n        tasks := make([]Task, numTasks)\n        for i := range tasks {\n                tasks[i] = Task(i + 1)\n        }\n        ProcessConcurrently(tasks, maxConcurrent,mockProcessTask)\n        if peakConcurrentCount > int32(maxConcurrent) {\n                t.Errorf(\"The peak number of concurrent tasks %v exceeded the limit of %v\", peakConcurrentCount, maxConcurrent)\n        }\n}"}}
{"canonical_solution": "import (\n\t\"container/heap\"\n)\n\ntype IntHeap []int\n\nfunc (h IntHeap) Len() int           { return len(h) }\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] } // 小顶堆\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *IntHeap) Push(x interface{}) {\n\t*h = append(*h, x.(int))\n}\n\nfunc (h *IntHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n\nfunc HeapSort(slice []int) []int {\n\th := IntHeap(slice)\n\theap.Init(&h)\n\tsorted := []int{}\n\n\tfor len(h) > 0 {\n\t\tsorted = append(sorted, heap.Pop(&h).(int))\n\t}\n\n\treturn sorted\n}", "content": "使用golang的结构实现一个[]int的堆排序算法，实现函数 `func HeapSort(slice []int) []int`", "id": 6, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "easy", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport (\n\t\"testing\"\n)\n#<INSERT>\n\nfunc TestHeapSort(t *testing.T) {\n\tunsorted := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}\n\tsorted := HeapSort(unsorted)\n\texpected := 3\n\tactual := sorted[4]\n\tif actual != expected {\n\t\tt.Errorf(\"not equal with expected expected %v actual %v\", expected, actual)\n\t\tt.FailNow()\n\t} else {\n\t\tt.Log(\"get data succeed\")\n\t}\n}"}}
{"canonical_solution": "type IPrint interface {\n\tPrintName() string\n}\n\ntype HDFS struct {\n\tName string\n}\n\ntype Kafka struct {\n\tName string\n}\n\nfunc CallName(p IPrint) string {\n\treturn p.PrintName()\n}\n\nfunc (h HDFS) PrintName() string {\n\treturn h.Name\n}\n\nfunc (k Kafka) PrintName() string {\n\treturn k.Name\n}", "content": "请用go语言回答，现在有一个接口IPrint和两个对象HDFS、Kafka，请实现如下功能：补全HDFS和Kafka的方法, 用以实现IPrint接口，并在最终的CallName()调用中，输出自己的Name:\n```go\ntype IPrint interface {\n    PrintName() string\n}\ntype HDFS struct{\n    Name string\n}\n\ntype Kafka struct{\n    Name string\n}\n\nfunc CallName(p IPrint) {\n    fmt.Println(p.Print())\n}\n```", "id": 8, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Others", "difficulty": "easy", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n\t\"testing\"\n)\n\n#<INSERT>\nfunc TestHDFS_PrintName(t *testing.T) {\n\thdfs := HDFS{Name: \"HDFS\"}\n\texpected := \"HDFS\"\n\tresult := hdfs.PrintName()\n\tif result != expected {\n\t\tt.Errorf(\"HDFS.PrintName() = %s; expected %s\", result, expected)\n\t\tt.FailNow()\n\t}\n}\n\nfunc TestKafka_PrintName(t *testing.T) {\n\tkafka := Kafka{Name: \"Kafka\"}\n\texpected := \"Kafka\"\n\tresult := kafka.PrintName()\n\tif result != expected {\n\t\tt.Errorf(\"Kafka.PrintName() = %s; expected %s\", result, expected)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "func CountEmployeesAgeLtV1(age int) int {\n\tcount := 0\n\tfor _, employee := range list {\n\t\tif employee.Age > age {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}", "content": "请用go语言回答，员工信息如下，请基于以下信息，统计出大于40岁的员工数量, 函数为CountEmployeesAgeLtV1(age int) int\n```go\ntype Employee struct {\n\tName     string\n\tAge      int\n\tVacation int\n\tSalary   int\n}\n\nvar list = []Employee{\n\t{\"Hao\", 44, 0, 8000},\n\t{\"Bob\", 34, 10, 5000},\n\t{\"Alice\", 23, 5, 9000},\n\t{\"Jack\", 26, 0, 4000},\n\t{\"Tom\", 48, 9, 7500},\n\t{\"Marry\", 29, 0, 6000},\n\t{\"Mike\", 32, 8, 4000},\n}\n```\n注意回答的代码中不要重复定义以上结构与变量", "id": 10, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport \"testing\"\n\ntype Employee struct {\n\tName     string\n\tAge      int\n\tVacation int\n\tSalary   int\n}\n\nvar list = []Employee{\n\t{\"Hao\", 44, 0, 8000},\n\t{\"Bob\", 34, 10, 5000},\n\t{\"Alice\", 23, 5, 9000},\n\t{\"Jack\", 26, 0, 4000},\n\t{\"Tom\", 48, 9, 7500},\n\t{\"Marry\", 29, 0, 6000},\n\t{\"Mike\", 32, 8, 4000},\n}\n\n#<INSERT>\nfunc TestEmploee_CountV1(t *testing.T) {\n\tresult := CountEmployeesAgeLtV1(40)\n\texpected := 2\n\tif result != expected {\n\t\tt.Errorf(\"The number of employees aged over 40 years old is %d; expected %d\", result, expected)\n\t\tt.FailNow()\n\t}\n\n}"}}
{"canonical_solution": "func GetMaxSubStringLength(str string) int {\n\tmaxLength := 0\n\tleftIndex := -1\n\trightIndex := 0\n\tcharMap := map[string]int{}\n\t\n\tfor rightIndex = 0; rightIndex < len(str); rightIndex++ {\n\t\tif idx, ok := charMap[string(str[rightIndex])]; ok && idx > leftIndex {\n\t\t\tleftIndex = idx\n\t\t} else {\n\t\t\tif rightIndex - leftIndex > maxLength {\n\t\t\t\tmaxLength = rightIndex - leftIndex\n\t\t\t}\n\t\t}\n\n\t\tcharMap[string(str[rightIndex])] = rightIndex\n\t}\n\n\treturn maxLength\n}", "content": "请用 go 语言，求一个字符串中最长无重复子串的长度，实现函数 `func GetMaxSubStringLength(str string) int`", "id": 11, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "easy", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n\n#<INSERT>\n\nfunc TestGetMaxSubStringLength(t *testing.T) {\n\tstr := \"abcdabcdeabcdabcd\"\n\texpect := 5\n\tresult := GetMaxSubStringLength(str)\n\n\tif result == expect {\n\t\tt.Log(\"get intersect success.\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected, expected: %v actual: %v\", expect, result)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "\nfunc IsIsomorphic(s, t string) bool {\n    s2t := map[byte]byte{}\n    t2s := map[byte]byte{}\n    for i := range s {\n        x, y := s[i], t[i]\n        if s2t[x] > 0 && s2t[x] != y || t2s[y] > 0 && t2s[y] != x {\n            return false\n        }\n        s2t[x] = y\n        t2s[y] = x\n    }\n    return true\n}", "content": "给定两个字符串 s 和 t ，请用 go 语言判断它们是否是同构的。\n\n如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。\n\n每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n实现函数 `func IsIsomorphic(s, t string) bool`", "id": 12, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n\n#<INSERT>\n\nfunc TestIsIsomorphic(t *testing.T) {\n\tstr1 := \"foo\"\n\tstr2 := \"add\"\n\texpect := true\n\tresult := IsIsomorphic(str1, str2)\n\n\tif result == expect {\n\t\tt.Log(\"get intersect success.\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected, expected: %v actual: %v\", expect, result)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "\nfunc ReverseString(str string) string {\n\ts := []byte(str)\n\tfor left, right := 0, len(s)-1; left < right; left++ {\n\t\ts[left], s[right] = s[right], s[left]\n\t\tright--\n\t}\n\n\treturn string(s)\n}", "content": "请用 go 语言编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出，实现函数 `func ReverseString(str string) string`", "id": 19, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n\n#<INSERT>\n\nfunc TestReverseString(t *testing.T) {\n\ts := \"abcd\"\n\texpect := \"dcba\"\n\tresult := ReverseString(s)\n\n\tif result == expect {\n\t\tt.Log(\"get intersect success.\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected, expected: %v actual: %v\", expect, result)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "func Map[F, T any](s []F, f func(F) T) []T {\n\tret := make([]T, 0, len(s))\n\tfor _, v := range s {\n\t\tret = append(ret, f(v))\n\t}\n\treturn ret\n}", "content": "使用go实现一个泛型函数 Map, 接受一个切片和一个函数作为参数。这个函数将被应用到切片的每个元素上，并返回一个新的切片，该切片包含函数应用后的结果。实现函数 `func Map[F, T any](s []F, f func(F) T) []T`", "id": 22, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n    \"reflect\"\n    \"testing\"\n    \"fmt\"\n)\n\n#<INSERT>\n\nfunc TestMap(t *testing.T) {\n    intSlice := []int{1, 2, 3}\n    intExpected := []int{2, 4, 6}\n    intResult := Map(intSlice, func(i int) int {\n        return i * 2\n    })\n    \n    if !reflect.DeepEqual(intResult, intExpected) {\n        t.Errorf(\"Map(%v) = %v; want %v\", intSlice, intResult, intExpected)\n    }\n\n    stringExpected := []string{\"1\", \"2\", \"3\"}\n    stringResult := Map(intSlice, func(i int) string {\n        return fmt.Sprintf(\"%d\", i)\n    })\n    \n    if !reflect.DeepEqual(stringResult, stringExpected) {\n        t.Errorf(\"Map(%v) = %v; want %v\", intSlice, stringResult, stringExpected)\n    }\n}"}}
{"canonical_solution": "\nfunc Contains(arr []string, tiem string) bool {\n\tfor _, v := range arr {\n\t\tif v == tiem {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "content": "请用 go 语言判断字符串数组中是否包含某个字符串，实现函数 `func Contains(arr []string, tiem string) bool`", "id": 24, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n\n#<INSERT>\n\nfunc TestContains(t *testing.T) {\n\tarr := []string{\"a\", \"b\", \"c\"}\n\tif Contains(arr, \"c\") && !Contains(arr, \"d\") {\n\t\tt.Log(\"get expect\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected\")\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "import (\n    \"math\"\n    \"sync\"\n)\nfunc makeRange(min, max int) []int {\n\ta := make([]int, max-min+1)\n\tfor i := range a {\n\t\ta[i] = min + i\n\t}\n\treturn a\n}\n\nfunc echo(nums []int) <-chan int {\n\tout := make(chan int)\n\tgo func() {\n\t\tfor _, n := range nums {\n\t\t\tout <- n\n\t\t}\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\nfunc CountArrayResult(from, to int) int {\n\tnums := makeRange(from, to)\n\tin := echo(nums)\n\n\tconst nProcess = 5\n\tvar chans [nProcess]<-chan int\n\tfor i := range chans {\n\t\tchans[i] = sum(prime(in))\n\t}\n\n\tfor n := range sum(merge(chans[:])) {\n\t\treturn n\n\t}\n\treturn -1\n}\n\nfunc is_prime(value int) bool {\n\tfor i := 2; i <= int(math.Floor(float64(value)/2)); i++ {\n\t\tif value%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn value > 1\n}\n\nfunc prime(in <-chan int) <-chan int {\n\tout := make(chan int)\n\tgo func() {\n\t\tfor n := range in {\n\t\t\tif is_prime(n) {\n\t\t\t\tout <- n\n\t\t\t}\n\t\t}\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\nfunc merge(cs []<-chan int) <-chan int {\n\tvar wg sync.WaitGroup\n\tout := make(chan int)\n\n\twg.Add(len(cs))\n\tfor _, c := range cs {\n\t\tgo func(c <-chan int) {\n\t\t\tfor n := range c {\n\t\t\t\tout <- n\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(c)\n\t}\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\nfunc sum(in <-chan int) <-chan int {\n\tout := make(chan int)\n\tgo func() {\n\t\tvar sum = 0\n\t\tfor n := range in {\n\t\t\tsum += n\n\t\t}\n\t\tout <- sum\n\t\tclose(out)\n\t}()\n\treturn out\n}", "content": "请用go语言回答，通过并发的方式对一个很长的数组中的质数进行求和运算，我们想先把数组分段求和，然后再把它们集中起来。\n要求：\n1. 制造从 from 到 to 的数组（包括 from 和 to 的值）；\n2. 把这堆数组全部 echo到一个 Channel 里；\n3. 生成 n 个 Channel，分别求和 ；\n4. 最后，把所有的结果再求和拼起来，得到最终的结果\n\n实现函数 `func CountArrayResult(from, to int) int` 完成该功能", "id": 245, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport \"testing\"\n\n#<INSERT>\n\nfunc InternalmakeRange(min, max int) []int {\n\ta := make([]int, max-min+1)\n\tfor i := range a {\n\t\ta[i] = min + i\n\t}\n\treturn a\n}\n\nfunc TestCountArrayResult(t *testing.T) {\n\tfrom := 1\n\tto := 10\n\tresult := CountArrayResult(from, to)\n\texpect := 0\n\tfor n := range InternalmakeRange(from, to) {\n\t\tif is_prime(n) {\n\t\t\texpect += n\n\t\t}\n\t}\n\tif expect != result {\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "func buildQuery(modelName string, serverTimeStart, serverTimeEnd, reqTimeStart, reqTimeEnd time.Time) string {\n\tconst dateFormat = \"2006-01-02\" \n\tquery := fmt.Sprintf(\n\t\t\"SELECT toDate(req_time) AS date, model_name, COUNT(1) AS count, \"+\n\t\t\t\"debiasAuc(predict{'head_1'}, label{'head_1'}, sample_rate{'head_1'}) AS debias_auc_0 \"+\n\t\t\t\"FROM `reckon_theta`.`deep_insight_theta` \"+\n\t\t\t\"WHERE toDate(server_time) BETWEEN '%s' AND '%s' \"+\n\t\t\t\"AND model_name IN ('%s') \"+\n\t\t\t\"AND toDate(req_time) BETWEEN '%s' AND '%s' \"+\n\t\t\t\"AND isNotNull(label{'head_1'}) \"+\n\t\t\t\"AND sample_rate{'head_1'} > 0 \"+\n\t\t\t\"GROUP BY (date, model_name) \"+\n\t\t\t\"ORDER BY (date, model_name) DESC \"+\n\t\t\t\"LIMIT 1000\",\n\t\tserverTimeStart.Format(dateFormat),\n\t\tserverTimeEnd.Format(dateFormat),\n\t\tmodelName,\n\t\treqTimeStart.Format(dateFormat),\n\t\treqTimeEnd.Format(dateFormat),\n\t)\n\treturn query\n}", "content": "使用golang实现一个函数,把这个sql里面的model_name server_time,req_time替换成变量。其中时间变量类型为time.Time\n```sql\nSELECT toDate(req_time) AS date, model_name, COUNT(1) AS count, debiasAuc(predict{'head_1'}, label{'head_1'}, sample_rate{'head_1'}) AS debias_auc_0 FROM `reckon_theta`.`deep_insight_theta` WHERE toDate(server_time) BETWEEN '2024-02-06' AND '2024-02-07' AND model_name IN ('aweme_ctr_base_streaming_1kbs_32p_r3180802_0') AND toDate(req_time) BETWEEN '2024-02-05' AND '2024-02-07' AND isNotNull(label{'head_1'}) AND sample_rate{'head_1'} > 0 GROUP BY (date, model_name) ORDER BY (date, model_name) DESC LIMIT 1000\n```", "id": 246, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "DataBase", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\n#<INSERT>\n\nfunc TestBuildQuery(t *testing.T) {\n\tmodelName := \"aweme_ctr_base_streaming_1kbs_32p_r3180802_0\"\n\tserverTimeStart := time.Date(2024, 2, 6, 0, 0, 0, 0, time.UTC)\n\tserverTimeEnd := time.Date(2024, 2, 7, 0, 0, 0, 0, time.UTC)\n\treqTimeStart := time.Date(2024, 2, 5, 0, 0, 0, 0, time.UTC)\n\treqTimeEnd := time.Date(2024, 2, 7, 0, 0, 0, 0, time.UTC)\n\n\texpectedQuery := \"SELECT toDate(req_time) AS date, model_name, COUNT(1) AS count, \" +\n\t\t\"debiasAuc(predict{'head_1'}, label{'head_1'}, sample_rate{'head_1'}) AS debias_auc_0 \" +\n\t\t\"FROM `reckon_theta`.`deep_insight_theta` \" +\n\t\t\"WHERE toDate(server_time) BETWEEN '2024-02-06' AND '2024-02-07' \" +\n\t\t\"AND model_name IN ('aweme_ctr_base_streaming_1kbs_32p_r3180802_0') \" +\n\t\t\"AND toDate(req_time) BETWEEN '2024-02-05' AND '2024-02-07' \" +\n\t\t\"AND isNotNull(label{'head_1'}) \" +\n\t\t\"AND sample_rate{'head_1'} > 0 \" +\n\t\t\"GROUP BY (date, model_name) \" +\n\t\t\"ORDER BY (date, model_name) DESC \" +\n\t\t\"LIMIT 1000\"\n\n\tquery := buildQuery(modelName, serverTimeStart, serverTimeEnd, reqTimeStart, reqTimeEnd)\n\n\tif query != expectedQuery {\n\t\tt.Errorf(\"Query does not match expected result.\\nExpected: %s\\nGot: %s\", expectedQuery, query)\n\t}\n}"}}
{"canonical_solution": "import (\n\t\"sync\"\n\t\"time\"\n)\ntype BlockMap struct {\n\tc   map[string]*entry\n\trmx sync.RWMutex\n}\n\ntype entry struct {\n\tvalue   interface{}\n\tisExist bool\n\tchannel chan interface{}\n}\n\nfunc NewBlockMap() *BlockMap {\n\tm := &BlockMap{\n\t\tc: make(map[string]*entry),\n\t}\n\treturn m\n}\n\nfunc (m *BlockMap) BSet(key string, val interface{}) {\n\tm.rmx.Lock()\n\tdefer m.rmx.Unlock()\n\tif e, ok := m.c[key]; !ok {\n\t\tm.c[key] = &entry{\n\t\t\tisExist: true,\n\t\t\tvalue:   val,\n\t\t}\n\t} else if !e.isExist {\n\t\te.isExist = true\n\t\tclose(e.channel)\n\t\te.channel = nil\n\t}\n}\n\nfunc (m *BlockMap) BGet(key string, timeout time.Duration) (interface{}, bool) {\n\tm.rmx.Lock()\n\tval, ok := m.c[key]\n\tif ok && val.isExist {\n\t\tm.rmx.Unlock()\n\t\treturn val.value, true\n\t} else if !ok {\n\t\tval = &entry{\n\t\t\tisExist: false,\n\t\t\tchannel: make(chan interface{}),\n\t\t}\n\t\tm.c[key] = val\n\t}\n\tvalChannel := val.channel\n\tm.rmx.Unlock()\n\n\ttimeoutChan := time.After(timeout)\n\n\tfor {\n\t\tselect {\n\t\tcase <-timeoutChan:\n\t\t\treturn nil, false\n\t\tcase <-valChannel:\n\t\t\tm.rmx.RLock()\n\t\t\tval, _ := m.c[key]\n\t\t\tm.rmx.RUnlock()\n\t\t\treturn val.value, true\n\t\t}\n\t}\n} ", "content": "实现一个map，满足在key不存在时，routine阻塞住，直到数据写入，对应接口如下。\n```go\ntype BMap interface {\n\tBSet(key string, val interface{})\n\tBGet(key string, timeout time.Duration) (interface{}, bool)\n}\n\n要求：\n1、实现的类型名为 `BlockMap`\n2、除上述接口外还需要实现 `func NewBlockMap() *BlockMap` 进行构造\n```", "id": 249, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport (\n\t\"testing\"\n)\n#<INSERT>\n\nfunc TestBlockMap(t *testing.T) {\n\tbm := NewBlockMap()\n\tbm.BSet(\"aaa\", \"bbb\")\n\tval, ok := bm.BGet(\"aaa\", 3*time.Second)\n\tif ok {\n\t\tif val.(string) != \"bbb\" {\n\t\t\tt.Errorf(\"not equal with expected bbb actual %v\", val)\n\t\t\tt.FailNow()\n\t\t} else {\n\t\t\tt.Log(\"get expected\")\n\t\t}\n\t}\n\tgo func() {\n\t\ttime.Sleep(10 * time.Second)\n\t\tbm.BSet(\"ccc\", \"ddd\")\n\t}()\n\t_, ok = bm.BGet(\"ccc\", 1*time.Second)\n\tif ok {\n\t\tt.Errorf(\"Fail expected timeout but get insteaded\")\n\t\tt.FailNow()\n\t} else {\n\t\tt.Log(\"get timeout \")\n\t}\n}"}}
{"canonical_solution": "\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\nfunc ForkJoin(nums []int) int {\n\tforkChan := make(chan int, 10)\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor _, num := range nums {\n\t\t\tforkChan <- num\n\t\t}\n\t}()\n\n\tjoinChan := make(chan int, 10)\n\tvar joinWg sync.WaitGroup\n\tjoinWg.Add(3)\n\tfor i := 0; i < 3; i++ {\n\t\tgo func(idx int) {\n\t\t\tdefer joinWg.Done()\n\t\t\tfor num := range forkChan {\n\t\t\t\tfmt.Printf(\"get num %v at %v\\n\", num, idx)\n\t\t\t\tjoinChan <- num\n\t\t\t}\n\t\t}(i)\n\t}\n\tres := 0\n\tvar mergeWg sync.WaitGroup\n\tmergeWg.Add(1)\n\tgo func() {\n\t\tdefer mergeWg.Done()\n\t\tfor num := range joinChan {\n\t\t\tres += num\n\t\t}\n\t}()\n\twg.Wait()\n\tclose(forkChan)\n\tjoinWg.Wait()\n\tclose(joinChan)\n\tmergeWg.Wait()\n\n\treturn res\n}  ", "content": "以下是使用Channel实现的ForkJoin功能的一个函数，使用ForkJoin方式计算所有数字的和，请确认下以下实现是否有问题，如有，正确实现代码该怎么做？\n```go\nfunc ForkJoin(nums []int) int {\n\tforkChan := make(chan int, 10)\n\tgo func() {\n\t\tfor _, num := range nums {\n\t\t\tforkChan <- num\n\t\t}\n\t}()\n\n\tjoinChan := make(chan int, 10)\n\tfor i := 0; i < 3; i++ {\n\t\tgo func(idx int) {\n\t\t\tfor num := range forkChan {\n\t\t\t\tfmt.Printf(\"get num %v at %v\\n\", num, idx)\n\t\t\t\tjoinChan <- num\n\t\t\t}\n\t\t\tclose(joinChan)\n\t\t}(i)\n\t}\n\tres := 0\n\tgo func() {\n\t\tfor num := range joinChan {\n\t\t\tres += num\n\t\t}\n\t}()\n\treturn res\n}\n```", "id": 255, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n#<INSERT>\nfunc TestForkJoin(t *testing.T) {\n\tnums := []int{1, 2, 3, 4, 5, 6}\n\tactual := ForkJoin(nums)\n\texpected := 21\n\tif actual != expected {\n\t\tt.Errorf(\"not equal with expected %v actual %v\", expected, actual)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t_ \"net/http/pprof\"\n\t\"strings\"\n)\n\nfunc StartPprofServer() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, World %s\", r.URL.Path)\n\t})\n\n\tport := \"8080\"\n\tfmt.Printf(\"Server is running at http://localhost:%s/\\n\", port)\n\n\thttp.ListenAndServe(\":\"+port, nil)\n}\n\nfunc GetPprofInfo() string {\n\turl := \"http://localhost:8080/debug/pprof\"\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error occurred while sending a GET request to %s: %s\", url, err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading response body: %s\", err)\n\t}\n\tsplits := strings.Split(string(body), \"\\n\")\n\tvar res []string\n\tfor _, split := range splits {\n\t\tif strings.HasPrefix(split, \"<title>\") {\n\t\t\tres = append(res, split)\n\t\t}\n\t}\n\tif len(res) != 0 {\n\t\treturn res[0]\n\t} else {\n\t\treturn \"\"\n\t}\n}", "content": "golang中，我们一般需要开启pprof来进行debug定位，请在golang服务中配置pprof并获取其中<title>对应的字段\n要求：\n1、实现函数 `func StartPprofServer()` 用于启动服务\n2、实现函数 `func GetPprofInfo() string` 用于响应请求", "id": 260, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Operating System", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n#<INSERT>\n\nfunc TestStartPprofServer(t *testing.T) {\n\tgo StartPprofServer()\n\tactual := GetPprofInfo()\n\texpected := \"<title>/debug/pprof/</title>\"\n\tif actual == expected {\n\t\tt.Log(\"get data succeed\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected expected %v actual %v\", expected, actual)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "\ntype Model struct {\n\tID        int\n\tStatus    string\n\tModelName string\n}\n\nfunc ReadModelsFromCSV(filePath string) ([]Model, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to open the CSV file: %v\", err)\n\t}\n\tdefer file.Close()\n\n\tvar models []Model\n\tr := csv.NewReader(file)\n\tif _, err := r.Read(); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to read the header row: %v\", err)\n\t}\n\n\tfor {\n\t\trecord, err := r.Read()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to read the CSV row: %v\", err)\n\t\t}\n\n\t\tid, err := strconv.Atoi(record[0])\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to parse the ID: %v\", err)\n\t\t}\n\n\t\tmodel := Model{\n\t\t\tID:        id,\n\t\t\tStatus:    record[1],\n\t\t\tModelName: record[2],\n\t\t}\n\t\tmodels = append(models, model)\n\t}\n\n\treturn models, nil\n}", "content": "有一个model的csv文件 包含 ID(int), Status(string), ModelName(string) 等列。使用golang编写一个函数读取scv文件解析成结构体列表\n要实现的函数签名应为：`func ReadModelsFromCSV(filePath string) ([]Model, error)`", "id": 264, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Data Analysis", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"reflect\"\n\t\"testing\"\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n    \"strconv\"\n)\n\n#<INSERT>\n\nfunc TestReadModelsFromCSV(t *testing.T) {\n\tcontent := []byte(\"id,status,model_name\\n1,active,ModelX\\n2,inactive,ModelY\")\n\ttmpfile, err := ioutil.TempFile(\"\", \"example.*.csv\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tmpfile.Name()) // 清理临时文件\n\n\tif _, err := tmpfile.Write(content); err != nil {\n\t\ttmpfile.Close()\n\t\tt.Fatal(err)\n\t}\n\tif err := tmpfile.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmodels, err := ReadModelsFromCSV(tmpfile.Name())\n\tif err != nil {\n\t\tt.Fatalf(\"ReadModelsFromCSV() error = %v\", err)\n\t}\n\n\twant := []Model{\n\t\t{ID: 1, Status: \"active\", ModelName: \"ModelX\"},\n\t\t{ID: 2, Status: \"inactive\", ModelName: \"ModelY\"},\n\t}\n\n\tif !reflect.DeepEqual(models, want) {\n\t\tt.Errorf(\"ReadModelsFromCSV() = %v, want %v\", models, want)\n\t}\n}"}}
{"canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc StartWebServer() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, World %s\", r.URL.Path)\n\t})\n\n\tport := \"8080\"\n\tfmt.Printf(\"Server is running at http://localhost:%s/\\n\", port)\n\n\thttp.ListenAndServe(\":\"+port, nil)\n}\n\nfunc GetHttpWorld() string {\n\turl := \"http://localhost:8080\"\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error occurred while sending a GET request to %s: %s\", url, err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading response body: %s\", err)\n\t}\n\treturn string(body)\n}", "content": "使用go快速建立一个webserver服务，用户访问请求时，直接返回\"Hello, World /\"\n要求：\n1、实现函数 `func StartWebServer()`，用于启动服务\n2、实现函数 `func GetHttpWorld() string`，用于响应请求", "id": 272, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Desktop and Web Development", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n#<INSERT>\nfunc TestStartWebServer(t *testing.T) {\n\tgo StartWebServer()\n\tactual := GetHttpWorld()\n\texpected := \"Hello, World /\"\n\tif actual == expected {\n\t\tt.Log(\"get data succeed\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected expected |%v| actual |%v|\", expected, actual)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "import (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc interleavedByChannel(nums []int, bytes []byte) (string, error) {\n\tif len(nums) != len(bytes) {\n\t\treturn \"\", fmt.Errorf(\"mismatch nums\")\n\t}\n\tsignalCh1 := make(chan int)\n\tsignalCh2 := make(chan int)\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\tvar res string\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor _, v := range nums {\n\t\t\tres += fmt.Sprintf(\"%v\", v)\n\t\t\tsignalCh1 <- 1\n\t\t\t<-signalCh2\n\t\t}\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor _, v := range bytes {\n\t\t\t<-signalCh1\n\t\t\tres += fmt.Sprintf(\"%c\", v)\n\t\t\tsignalCh2 <- 1\n\t\t}\n\t}()\n\twg.Wait()\n\treturn res, nil\n}", "content": "使用golang实现一个函数 `interleavedByChannel(nums []int, bytes []byte) (string, error)`，函数里各起2个协程，每个协程负责产出一个array的元素到string中，2协程通过channel交互打印，结果保留在返回的字符串中，如果不对齐，则返回mismatch nums异常，退出后函数不能泄漏协程。", "id": 274, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n\n#<INSERT>\n\nfunc TestInterleavedByChannel(t *testing.T) {\n\tnums := []int{1, 2, 3, 4}\n\tbytes := []byte{'a', 'b', 'c', 'd'}\n\texpected := \"1a2b3c4d\"\n\tactual, _ := interleavedByChannel(nums, bytes)\n\tif actual != expected {\n\t\tt.Errorf(\"not equal with expected %v actual %v\", expected, actual)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "\ntype User struct {\n\tFirstName string `json:\"firstName\"`\n\tLastName  string `json:\"lastName\"`\n\tAge       int    `json:\"-\"`\n}\n\nfunc SerializeUser(u User) (string, error) {\n\tjsonBytes, err := json.Marshal(u)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(jsonBytes), nil\n}\n\nfunc DeserializeUser(jsonStr string) (User, error) {\n\tvar u User\n\terr := json.Unmarshal([]byte(jsonStr), &u)\n\tif err != nil {\n\t\treturn User{}, err\n\t}\n\treturn u, nil\n}", "content": "使用 Go 语言编写代码，实现一个用户结构体 `User` 的 JSON 序列化与反序列化。\n 结构体 `User` 包含 `FirstName`、`LastName` 和 `Age` 字段。\n 要求：\n`FirstName` 和 `LastName` 字段在 JSON 中使用小写字母开头（即 `firstName` 和 `lastName`）。\n`Age` 字段在 JSON 中不显示，即使它有值。\n要实现的函数签名分别为：`func SerializeUser(u User) (string, error)` 和 `func DeserializeUser(jsonStr string) (User, error)`", "id": 276, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Others", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n\t\"testing\"\n\t\"encoding/json\"\n)\n\n#<INSERT>\n\nfunc TestSerializeUser(t *testing.T) {\n\tuser := User{\n\t\tFirstName: \"John\",\n\t\tLastName:  \"Doe\",\n\t\tAge:       30,\n\t}\n\twant := `{\"firstName\":\"John\",\"lastName\":\"Doe\"}`\n\n\tgot, err := SerializeUser(user)\n\tif err != nil {\n\t\tt.Fatalf(\"SerializeUser() error = %v\", err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"SerializeUser() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestDeserializeUser(t *testing.T) {\n\tjsonStr := `{\"firstName\":\"Jane\",\"lastName\":\"Doe\",\"age\":25}`\n\twant := User{\n\t\tFirstName: \"Jane\",\n\t\tLastName:  \"Doe\",\n\t}\n\n\tgot, err := DeserializeUser(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"DeserializeUser() error = %v\", err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"DeserializeUser() = %+v, want %+v\", got, want)\n\t}\n}"}}
{"canonical_solution": "\nimport (\n\t\"math\"\n)\n\nfunc MinSubArrayLen(s int, nums []int) int {\n    n := len(nums)\n    if n == 0 {\n        return 0\n    }\n    ans := math.MaxInt32\n    start, end := 0, 0\n    sum := 0\n    for end < n {\n        sum += nums[end]\n        for sum >= s {\n            ans = min(ans, end - start + 1)\n            sum -= nums[start]\n            start++\n        }\n        end++\n    }\n    if ans == math.MaxInt32 {\n        return 0\n    }\n    return ans\n}\n\nfunc min(x, y int) int {\n    if x < y {\n        return x\n    }\n    return y\n}", "content": "给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0\n请用go语言回答，实现函数 `func MinSubArrayLen(s int, nums []int) int`", "id": 278, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n\n#<INSERT>\n\nfunc TestMinSubArrayLen(t *testing.T) {\n\ttarget := 7\n\tnumbList := []int{2, 3, 1, 2, 4, 3}\n\texpect := 2\n\tresult := MinSubArrayLen(target, numbList)\n\n\tif result == expect {\n\t\tt.Log(\"get intersect success.\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected, expected: %v actual: %v\", expect, result)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "import (\n    \"sort\"\n)\n\ntype User struct {\n    FirstName string\n    LastName  string\n}\n\nfunc SortUsersByLastName(users []User) {\n    sort.SliceStable(users, func(i, j int) bool {\n        if users[i].LastName == users[j].LastName {\n            return users[i].FirstName < users[j].FirstName\n        }\n        return users[i].LastName < users[j].LastName\n    })\n}", "content": "有一个用户结构体 User，有 FirstName 和 LastName 两个字段。使用golang编写一个函数 SortUsersByLastName，接受一个 User 切片并按照 LastName 字段对其进行排序。如果 LastName 相同，则按照 FirstName 进一步排序。\n```go\ntype User struct {\n    FirstName string\n    LastName  string\n}\n```", "id": 280, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "easy", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n#<INSERT>\n\nfunc TestSortUsersByLastName(t *testing.T) {\n    users := []User{\n        {\"John\", \"Doe\"},\n        {\"Jane\", \"Smith\"},\n        {\"Alice\", \"Doe\"},\n    }\n\n    expected := []User{\n        {\"Alice\", \"Doe\"},\n        {\"John\", \"Doe\"},\n        {\"Jane\", \"Smith\"},\n    }\n\n    SortUsersByLastName(users)\n\n    if !reflect.DeepEqual(users, expected) {\n        t.Errorf(\"SortUsersByLastName() = %v; want %v\", users, expected)\n    }\n}"}}
{"canonical_solution": "\nimport (\n    \"bytes\"\n)\n\ntype LinkCard struct {\n\tTitle   string\n\tContent string\n\tURL     string\n}\n\nfunc GenerateLinkCard(lc LinkCard, tmplStr string) (string, error) {\n\ttmpl, err := template.New(\"linkCard\").Parse(tmplStr)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar result bytes.Buffer\n\terr = tmpl.Execute(&result, lc)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn result.String(), nil\n}", "content": "使用 Go 语言编写代码，实现一个生成带有链接的消息卡片的功能。\n要求：\n定义一个名为 LinkCard 的结构体，包含 Title、Content 和 URL 字段，分别表示卡片标题、内容和跳转链接。\n编写一个名为 GenerateLinkCard 的函数，接受一个 LinkCard 对象和一个模板字符串，然后根据模板和对象返回一个消息卡片字符串。", "id": 281, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Desktop and Web Development", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n\t\"text/template\"\n\t\"testing\"\n)\n\n#<INSERT>\n\n\nfunc TestGenerateLinkCard(t *testing.T) {\n\tcard := LinkCard{\n\t\tTitle:   \"通知\",\n\t\tContent: \"您有工单待处理，请前往处理\",\n\t\tURL:     \"https://xxx.com\",\n\t}\n\ttemplateStr := \"{{.Title}}\\n{{.Content}}\\nMore info: {{.URL}}\"\n\n\twant := \"通知\\n您有工单待处理，请前往处理\\nMore info: https://xxx.com\"\n\n\tgot, err := GenerateLinkCard(card, templateStr)\n\tif err != nil {\n\t\tt.Fatalf(\"GenerateLinkCard() error = %v\", err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"GenerateLinkCard() = %v, want %v\", got, want)\n\t}\n}"}}
{"canonical_solution": "import (\n\t\"sync\"\n)\n\nfunc debug_goroutine() sync.Map {\n\tvar set sync.Map\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tset.Store(i, true)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n\treturn set\n}", "content": "请用go语言回答，有如下代码，希望把1到10都返回回来，但是这段代码有问题，请找出并改正\n```go\nimport (\n\t\"sync\"\n)\n\nfunc debug_goroutine() sync.Map {\n\tvar set sync.Map\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tset.Store(i, true)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\treturn set\n}\n```", "id": 282, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Desktop and Web Development", "difficulty": "easy", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\n#<INSERT>\nfunc Test_DebugPrint(t *testing.T) {\n\tfmt.Print(\"hh\")\n\tresult := debug_goroutine()\n\tfor i := 0; i < 10; i++ {\n\t\t_, ok := result.Load(i)\n\t\tif !ok {\n\t\t\tt.FailNow()\n\t\t}\n\t}\n}"}}
{"canonical_solution": "\nconst timeLayout = \"2006年1月2日 15:04:05\"\n\nfunc calculateDurationBetweenTwoTimes(startTimeStr, endTimeStr string) (time.Duration, error) {\n    startTime, err := time.Parse(timeLayout, startTimeStr)\n    if err != nil {\n        return 0, err\n    }\n    endTime, err := time.Parse(timeLayout, endTimeStr)\n    if err != nil {\n        return 0, err\n    }\n    return endTime.Sub(startTime), nil\n}", "content": "使用golang实现一个函数 calculateDurationBetweenTwoTimes 接收两个时间字符串并返回它们之间的间隔。字符串格式: 2024年3月18日 11:07:18", "id": 283, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "\npackage main\nimport (\n    \"testing\"\n    \"time\"\n)\n\n#<INSERT>\n\nfunc TestCalculateDurationBetweenTwoTimes(t *testing.T) {\n    tests := []struct {\n        startTimeStr string\n        endTimeStr   string\n        expected     time.Duration\n        expectError  bool\n    }{\n        {\n            startTimeStr: \"2024年3月18日 11:07:18\",\n            endTimeStr:   \"2024年3月19日 12:08:19\",\n            expected:     25*time.Hour + 1*time.Minute + 1*time.Second,\n            expectError:  false,\n        },\n        {\n            startTimeStr: \"2024年3月18日 11:07:18\",\n            endTimeStr:   \"不正确的时间格式\",\n            expected:     0,\n            expectError:  true,\n        },\n    }\n\n    for _, test := range tests {\n        duration, err := calculateDurationBetweenTwoTimes(test.startTimeStr, test.endTimeStr)\n        if test.expectError {\n            if err == nil {\n                t.Errorf(\"Expected an error for start time %s and end time %s\", test.startTimeStr, test.endTimeStr)\n            }\n        } else {\n            if err != nil {\n                t.Errorf(\"Did not expect an error for start time %s and end time %s: %v\", test.startTimeStr, test.endTimeStr, err)\n            }\n            if duration != test.expected {\n                t.Errorf(\"Expected duration %v, but got %v for start time %s and end time %s\", test.expected, duration, test.startTimeStr, test.endTimeStr)\n            }\n        }\n    }\n}"}}
{"canonical_solution": "import (\n\t\"sync\"\n)\nfunc DebugSyncMap() string {\n\tvar m sync.Map\n\tm.Store(\"address\", map[string]string{\"province\": \"Jiangsu\", \"city\": \"Nanjing\"})\n\tv, _ := m.Load(\"address\")\n\treturn v.(map[string]string)[\"province\"]\n}", "content": "对于下列代码，判断是否有问题，并且如果有问题，请展示出对应的正确代码\n```go\nimport (\n\t\"sync\"\n)\nfunc DebugSyncMap() string {\n\tvar m sync.Map\n\tm.Store(\"address\", map[string]string{\"province\": \"Jiangsu\", \"city\": \"Nanjing\"})\n\tv, _ := m.Load(\"address\")\n\treturn v[\"province\"]\n}\n```", "id": 284, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "easy", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport (\n\t\"testing\"\n)\n#<INSERT>\nfunc TestDebugSyncMap(t *testing.T) {\n\tactual := DebugSyncMap()\n\texpected := \"Jiangsu\"\n\tif actual != expected {\n\t\tt.Errorf(\"not equal with expected expected %v actual %v\", expected, actual)\n\t\tt.FailNow()\n\t} else {\n\t\tt.Log(\"get data succeed\")\n\t}\n}"}}
{"canonical_solution": "import (\n    \"sort\"\n)\n\nfunc FrequencySort(nums []int) []int {\n\tcnt := map[int]int{}\n\tfor _, x := range nums {\n\t\tcnt[x]++\n\t}\n\tsort.Slice(nums, func(i, j int) bool {\n\t\ta, b := nums[i], nums[j]\n\t\treturn cnt[a] < cnt[b] || cnt[a] == cnt[b] && a > b\n\t})\n\treturn nums\n}", "content": "输入一个整数数组 nums ，请用 go 语言将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，按照数值本身将它们 降序 排序。 \n实现函数 `func FrequencySort(nums []int) []int`", "id": 285, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Advanced Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport (\n    \"testing\"\n    \"encoding/json\"\n)\n\n#<INSERT>\n\nfunc TestFrequencySort(t *testing.T) {\n\tnums := []int{2, 3, 1, 3, 2}\n\texpect := \"[1,3,3,2,2]\"\n\tval, _ := json.Marshal(FrequencySort(nums))\n\tresult := string(val)\n\n\tif result == expect {\n\t\tt.Log(\"get intersect success.\")\n\t} else {\n\t\tt.Errorf(\"not equal with expected, expected: %v actual: %v\", expect, result)\n\t\tt.FailNow()\n\t}\n}"}}
{"canonical_solution": "\nfunc countLines(filePath string) (int, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tlineCount := 0\n\tfor scanner.Scan() {\n\t\tlineCount++\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn 0, err\n\t}\n\treturn lineCount, nil\n}", "content": "使用go实现一个函数，接受一个文件路径作为参数，输出文件的行数。", "id": 286, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"testing\"\n)\n\n#<INSERT>\n\nfunc setup(t *testing.T) (string, func()) {\n\tt.Helper()\n\ttmpFile, err := os.CreateTemp(\"\", \"linecounter\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create temporary file: %v\", err)\n\t}\n\tcontent := []byte(\"Line 1\\nLine 2\\nLine 3\\n\")\n\tif _, err := tmpFile.Write(content); err != nil {\n\t\tos.Remove(tmpFile.Name())\n\t\tt.Fatalf(\"Unable to write to temporary file: %v\", err)\n\t}\n\tif err := tmpFile.Close(); err != nil {\n\t\tos.Remove(tmpFile.Name())\n\t\tt.Fatalf(\"Unable to close temporary file: %v\", err)\n\t}\n\n\treturn tmpFile.Name(), func() {\n\t\tos.Remove(tmpFile.Name())\n\t}\n}\n\nfunc TestCountLines(t *testing.T) {\n\tfilePath, teardown := setup(t)\n\tdefer teardown()\n\n\twant := 3\n\tgot, err := countLines(filePath)\n\tif err != nil {\n\t\tt.Errorf(\"countLines() error = %v\", err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"countLines() = %d, want %d\", got, want)\n\t}\n}"}}
{"canonical_solution": "import (\n\t\"fmt\"\n)\nfunc channelDebug() int {\n\tch1 := make(chan int)\n\tgo func() {\n\t\tfmt.Println(<-ch1)\n\t}()\n\tch1 <- 5\n\treturn 10\n}", "content": "下面是一段golang的代码，请确认下此代码运行结果。如果有问题请指出问题并fix\n```go\nfunc channelDebug() int {\n\tch1 := make(chan int)\n\tgo fmt.Println(<-ch1)\n\tch1 <- 5\n\treturn 10\n}\n```", "id": 287, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\nimport \"testing\"\n#<INSERT>\nfunc TestChannelDebug(t *testing.T) {\n\tactual := channelDebug()\n\texpected := 10\n\tif actual != expected {\n\t\tt.Errorf(\"not equal with expected %v actual %v\", expected, actual)\n\t\tt.FailNow()\n\t}\n\n}"}}
{"canonical_solution": "import (\n    \"regexp\"\n)\n\nfunc ExtractErrorMessages(log string) []string {\n\tre := regexp.MustCompile(`(?m)^ERROR:.*$`)\n\tmatches := re.FindAllString(log, -1)\n\treturn matches\n}", "content": "使用 Go 语言实现一个名为 ExtractErrorMessages 的函数，它接受一个多行的日志字符串，并返回所有错误消息的切片。\n假设错误消息以 \"ERROR:\" 开头，并且每条错误消息占据一行。", "id": 288, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\n#<INSERT>\n\nfunc TestExtractErrorMessages(t *testing.T) {\n\tlogs := `INFO: Starting the application...\nERROR: Failed to load configuration.\nINFO: Trying to reconnect...\nERROR: Connection timed out.\nINFO: Process completed.`\n\n\twant := []string{\n\t\t\"ERROR: Failed to load configuration.\",\n\t\t\"ERROR: Connection timed out.\",\n\t}\n\n\tgot := ExtractErrorMessages(logs)\n\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"ExtractErrorMessages() = %v, want %v\", got, want)\n\t}\n}"}}
{"canonical_solution": "func debug_new_map() {\n\tmp := make(map[int]int)\n\tf := func(m map[int]int) {\n\t\tm[10] = 10\n\t}\n\tf(mp)\n}", "content": "请用go语言回答，有如下代码，创建map并赋值，但是无法成功，请修正\n```go\nfunc debug_new_map() {\n\tmp := new(map[int]int)\n\tf := func(m map[int]int) {\n\t\tm[10] = 10\n\t}\n\tf(*mp)\n}\n```", "id": 289, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "medium", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "package main\n\nimport \"testing\"\n#<INSERT>\n\nfunc Test_DebugNewMap(t *testing.T) {\n\tdebug_new_map()\n}"}}
{"canonical_solution": "func debug_recover() {\n\tdefer func() {\n\t\trecover()\n\t}()\n\tpanic(1)\n}", "content": "请用go语言回答，有如下代码，希望捕获panic，但是没有成功，请修改代码完成需求\n```go\nfunc debug_recover() {\n\tdefer func() {\n\t\tfunc() { recover() }()\n\t}()\n\tpanic(1)\n}\n```", "id": 290, "labels": {"programming_language": "go", "execution_language": "go_test", "category": "Basic Programming", "difficulty": "hard", "fewshot": "问题：写一段 golang 代码实现以下功能。\n找出小于第n个斐波那契数的最大完全平方数\n函数签名为 `func maxSquareNumber(n int) int`\n\n答案：\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maxSquareNumber(n int) int {\n\tif n <= 2 {\n\t\treturn 0\n\t}\n\n\tfibs := []int{0, 1}\n\tvar maxSquare int\n\n\tfor i := 2; i <= n; i++ {\n\t\tfibs = append(fibs, fibs[i-1]+fibs[i-2])\n\t}\n\n\tfib := fibs[len(fibs)-1]\n\tperfectSquares := make([]int, 0)\n\tfor i := 1; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tperfectSquares = append(perfectSquares, i*i)\n\t}\n\n\tmaxSquare = 0\n\tfor _, square := range perfectSquares {\n\t\tif square < fib {\n\t\t\tmaxSquare = square\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn maxSquare\n}\n```\n\n----------------", "locale": "zh"}, "test": {"code": "// Test\npackage main\nimport \"testing\"\n#<INSERT>\nfunc Test_DebugRecover(t *testing.T) {\n\tdebug_recover()\n}"}}
